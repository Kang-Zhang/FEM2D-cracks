#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include <string.h>
#include "Tokenizer.hh"
#include "die.hh"

// global variables

static double EPS = 1e-6;
static double surface_thickness = 1.0;
static FILE * infile = stdin;
static int use_xyz_growth = 0;

static void usage( int ret = -1)
{
	die( "Usage: surface2fem [-xyz_growth] <thickness>\n");
	exit( ret);
}

static void parse_command_line( int argc, char ** argv)
{
 	long i = 1;
 	while( 1) {
 		if( strcmp( argv[i], "-xyz_growth") == 0) {
			use_xyz_growth = 1;
			i ++;
			continue;
		}
		// last arg. must be a number
		if( i != argc-1) usage();
		if( sscanf( argv[i], "%lf", & surface_thickness) != 1) {
			usage();
		} else {
			break;
		}
	}
}

class Vertex {
public:
	double x, y, z;		// coordinates
	double nx, ny, nz;	// normal
	long nref;
	long id;

	Vertex() {
		nref = 0;
		id = -1;
	}

	void normalize_normal( void) {
		double d = sqrt( nx*nx + ny*ny + nz*nz);
		if( d > EPS) {
			nx /= d;
			ny /= d;
			nz /= d;
		}
	}
};

class Element {
public:
	long p1, p2, p3, p4, p5, p6;
};

int main( int argc, char ** argv)
//
// read in surface file and generate a FEM file for simulations
//
// - there could be vertices that are not referenced - remove them
//
{
	parse_command_line( argc, argv);

	// read number of vertices and number of triangles
	long n_vertices = Tokenizer::read_long(infile, "number of vertices");
	long n_triangles = Tokenizer::read_long(infile, "number of triangles");

	fprintf( stderr, "Reading in %ld vertices...", n_vertices);

	// read in all vertices
	Vertex * vertices = new Vertex[ 2 * n_vertices];
	for( long i = 0 ; i < n_vertices ; i ++) {
		Vertex & v = vertices[2*i];
		v.x = Tokenizer::read_double( infile, "x");
		v.y = Tokenizer::read_double( infile, "y");
		v.z = Tokenizer::read_double( infile, "z");
		v.nx = Tokenizer::read_double( infile, "nx");
		v.ny = Tokenizer::read_double( infile, "ny");
		v.nz = Tokenizer::read_double( infile, "nz");
		v.normalize_normal();
		// add an extrapolated point
		Vertex & w = vertices[2*i+1];
		w.x = v.x + surface_thickness * v.nx;
		w.y = v.y + surface_thickness * v.ny;
		w.z = v.z + surface_thickness * v.nz;
	}

	fprintf( stderr, "done.\n");
	fprintf( stderr, "Reading in %ld triangles...", n_triangles);

	// read all triangles
	Element * elements = new Element[ n_triangles];
	for( long i = 0 ; i < n_triangles ; i ++) {
		Element & e = elements[i];
		long p1 = Tokenizer::read_long( infile, "p1");
		long p2 = Tokenizer::read_long( infile, "p2");
		long p3 = Tokenizer::read_long( infile, "p3");
		assert( p1 >= 0);
		assert( p1 < n_vertices);
		assert( p2 >= 0);
		assert( p2 < n_vertices);
		assert( p3 >= 0);
		assert( p3 < n_vertices);
		e.p4 = p1 * 2;
		e.p5 = p3 * 2;
		e.p6 = p2 * 2;
		e.p1 = p1 * 2 + 1;
		e.p2 = p3 * 2 + 1;
		e.p3 = p2 * 2 + 1;
		vertices[e.p1].nref ++;
		vertices[e.p2].nref ++;
		vertices[e.p3].nref ++;
		vertices[e.p4].nref ++;
		vertices[e.p5].nref ++;
		vertices[e.p6].nref ++;
	}

	fprintf( stderr, "done.\n");

	// determine the bounding box of the model
	double minx = vertices[0].x;
	double miny = vertices[0].y;
	double minz = vertices[0].z;
	double maxx = vertices[0].x;
	double maxy = vertices[0].y;
	double maxz = vertices[0].z;
	for( long i = 0 ; i < n_vertices * 2 ; i ++) {
		Vertex & v = vertices[i];
		if( v.x < minx) minx = v.x;
		if( v.x > maxx) maxx = v.x;
		if( v.y < miny) miny = v.y;
		if( v.y > maxy) maxy = v.y;
		if( v.z < minz) minz = v.z;
		if( v.z > maxz) maxz = v.z;
	}
	// calculate center of the bounding box
	double cx = (maxx+minx) / 2.0;
	double cy = (maxy+miny) / 2.0;
	double cz = (maxz+minz) / 2.0;
	// shift all vertices to be centered around (0,0,0)
	for( long i = 0 ; i < n_vertices * 2 ; i ++) {
		Vertex & v = vertices[i];
		v.x -= cx;
		v.y -= cy;
		v.z -= cz;
	}

	// renumber referenced vertices - so that the unreferenced nodes
	// can be deleted
	long n = 0;
	for( long i = 0 ; i < n_vertices * 2 ; i ++) {
		if( vertices[i].nref == 0) continue;
		vertices[i].id = n;
		n ++;
	}
	fprintf( stderr, "Unreferenced nodes = %ld (%ld orig)\n",
		 n_vertices * 2 - n,
		 (n_vertices * 2 - n) / 2);

	// print out the model
	printf( "# FEM data generated by surface2fem\n");
	printf( "# surface thickness = %f\n", surface_thickness);
	printf( "\n");
	
	if( ! use_xyz_growth)
		printf( "use_surface_normal_growth\n");
	else
		printf( "# !!! not requested !!! use_surface_normal_growth\n");
	printf( "%ld # number of nodes\n", n);
	
	for( long i = 0 ; i < n_vertices * 2 ; i ++) {
		Vertex & v = vertices[i];
		if( v.nref == 0) continue;
		if( use_xyz_growth)
			printf( "%.6f %.6f %.6f %.6f %.6f %.6f %d\n",
				v.x, v.y, v.z,
				0.0, 0.0, 0.0,
				(i%2==0) ? 1 : 0);
		else
			printf( "%.6f %.6f %.6f %.6f %.6f %.6f "
				"%.6f %.6f %.6f %d\n",
				v.x, v.y, v.z,
				0.0, 0.0, 0.0,
				v.nx, v.ny, v.nz,
				(i%2==0) ? 1 : 0);
	}

	printf( "\n");
	printf( "# description of how to randomize material properties\n");
	printf( "BEGIN material_properties\n");
	printf( "\tyoung_modulus constant 100.0\n");
	printf( "\tpoisson_ratio constant 0.3\n");
	printf( "\tyield_stress constant 5.0\n");
	printf( "END material_properties\n");
	
	printf( "\n");
	printf( "%ld # number of elements\n", n_triangles);
	printf( "\n");
	for( long i = 0 ; i < n_triangles ; i ++) {
		Element & e = elements[i];
		printf( "fivewall %ld %ld %ld %ld %ld %ld %ld\n",
			i,
			vertices[ e.p1].id,
			vertices[ e.p2].id,
			vertices[ e.p3].id,
			vertices[ e.p4].id,
			vertices[ e.p5].id,
			vertices[ e.p6].id);
	}
	
	printf( "\n");
	printf( "sim_time_total = 1.0\n");
	printf( "sim_time_step = 0.1\n");
	printf( "sim_time_curr = 0.0\n");
	printf( "growth_x = 0.1\n");
	printf( "growth_y = 0.1\n");
	printf( "growth_z = 0.1\n");
	printf( "gravity_x = 0.0\n");
	printf( "gravity_y = 0.0\n");
	printf( "gravity_z = 0.0\n");
	printf( "max_break_size = 0.001\n");
	printf( "precision = 1e-7\n");
	printf( "\n");
	printf( "progressive_save = true\n");
	printf( "progressive_save_fmask = \"/scratch/federl/%%N-%%T.res\"\n");
	printf( "progressive_save_skip = 0\n");
	printf( "\n");
	
	return 0;
}
